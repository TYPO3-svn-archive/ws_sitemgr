.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MK-TABLE-SYNC 1p"
.TH MK-TABLE-SYNC 1p "2008-08-12" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
mk\-table\-sync \- Synchronize MySQL tables efficiently.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
It is a good idea to back up your data and run \f(CW\*(C`mk\-table\-sync\*(C'\fR with \*(L"\-\-test\*(R"
first, to see what will happen.  If you want to see which rows are different
without changing the tables, use \*(L"\-\-print\*(R" instead of \*(L"\-\-execute\*(R".
.PP
To sync db.tbl1 from host1 to host2:
.PP
.Vb 1
\&   mk\-table\-sync \-\-execute u=user,p=pass,h=host1,D=db,t=tbl host2
.Ve
.PP
Sync all tables in host1 to host2 and host3:
.PP
.Vb 1
\&   mk\-table\-sync \-\-execute host1 host2 host3
.Ve
.PP
Resolve differences mk-table-checksum found on this master's slaves:
.PP
.Vb 1
\&   mk\-table\-sync \-\-execute \-\-replicate test.checksum master1
.Ve
.PP
Sync this slave to its replication master:
.PP
.Vb 1
\&   mk\-table\-sync \-\-execute \-\-synctomaster slave1
.Ve
.PP
Sync this slave to its replication master, resolving differences
mk-table-checksum found:
.PP
.Vb 1
\&   mk\-table\-sync \-\-execute \-\-synctomaster \-\-replicate test.checksum slave1
.Ve
.PP
Sync server2 in a master-master replication configuration, where server2's copy
of db1.tbl1 is known or suspected to be incorrect:
.PP
.Vb 1
\&   mk\-table\-sync \-\-execute \-\-synctomaster h=server2,D=db1,t=tbl1
.Ve
.PP
Note that in the master-master configuration, the following will \s-1NOT\s0 do what you
want, because it will make changes directly on server2, which will then flow
through replication and change server1's data:
.PP
.Vb 2
\&   # Don't do this in a master\-master setup!
\&   mk\-table\-sync \-\-execute h=server1,D=db1,t=tbl1 h=server2
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1WARNING\s0\fR this tool is unfinished and could perform slowly.  The Chunk
algorithm is great when it can be used, and so is Nibble, but otherwise GroupBy
is the default choice and it may not perform very well.  Please run with
\&\*(L"\-\-test\*(R" before subjecting your servers to this tool, and make backups of
your data!
.PP
This tool is designed to do one-way synchronization of data (two\-way sync is
planned for the future).  It finds differences efficiently with one of several
algorithms (see \*(L"\s-1ALGORITHMS\s0\*(R").  It makes changes on the destination table(s)
so it matches the source.
.PP
It does \fBnot\fR synchronize table structures, indexes, or any other schema
changes.  It synchronizes only data.
.PP
It can operate through replication by comparing a slave with its master and
making changes on the master.  These changes will flow through replication and
correct any differences found on the slave.
.PP
It accepts a list of DSNs (see the \*(L"\-\-help\*(R" output) to tell it where and how
to connect.
.PP
There are many ways to invoke it.  The following is the abbreviated logic:
.PP
.Vb 20
\&   if DSN has a t part, sync only that table:
\&      if 1 DSN:
\&         if \-\-synctomaster:
\&            The DSN is a slave.  Connect to its master and sync.
\&      if more than 1 DSN:
\&         The first DSN is the source.  Sync each DSN in turn.
\&   else if \-\-replicate:
\&      if \-\-synctomaster:
\&         The DSN is a slave.  Connect to its master, find records
\&         of differences, and fix.
\&      else:
\&         The DSN is the master.  Find slaves and connect to each,
\&         find records of differences, and fix.
\&   else:
\&      if only 1 DSN and \-\-synctomaster:
\&         The DSN is a slave.  Connect to its master, find tables and
\&         filter with \-\-databases etc, and sync each table to the master.
\&      else:
\&         find tables, filtering with \-\-databases etc, and sync each
\&         DSN to the first.
.Ve
.SH "REPLICATION SAFETY"
.IX Header "REPLICATION SAFETY"
Synchronizing a replication master and slave safely is a non-trivial problem, in
general.  There are all sorts of issues to think about, such as other processes
changing data, trying to change data on the slave, whether the destination and
source are a master-master pair, and much more.
.PP
In general, the safe way to do it is to change the data on the master, and let
the changes flow through replication to the slave like any other changes.
However, this works only if it's possible to \s-1REPLACE\s0 into the table on the
master.  \s-1REPLACE\s0 works only if there's a unique index on the table (otherwise it
just acts like an ordinary \s-1INSERT\s0).
.PP
If your table have unique keys, you should use the \*(L"\-\-synctomaster\*(R" and/or
\&\*(L"\-\-replicate\*(R" options to sync a slave to its master.  This will generally do
the right thing.  When there is no unique key on the table, there is no choice
but to change the data on the slave, and mk-table-sync will detect that you're
trying to do so.  It will complain and die unless you specify the
\&\*(L"\-\-skipslavecheck\*(R" option.
.PP
If you're syncing a table without a primary or unique key on a master-master
pair, you must change the data on the destination server.  Therefore, you need
to use the \*(L"\-\-skipbinlog\*(R" option for safety.  If you don't, the changes you
make on the destination server will replicate back to the source server and
change the data there!
.PP
The generally safe thing to do on a master-master pair is to use the
\&\*(L"\-\-synctomaster\*(R" option so you don't change the data on the destination
server.  You will also need to use the \*(L"\-\-skipslavecheck\*(R" option to keep
mk-table-sync from complaining that it is changing data on a slave.
.SH "ALGORITHMS"
.IX Header "ALGORITHMS"
This tool has a generic data-syncing framework, within which it is possible to
use any number of different algorithms to actually find differences.  It chooses
the best algorithm automatically.  While I plan to add more algorithms in the
future, the following are implemented now:
.IP "Chunk" 4
.IX Item "Chunk"
Finds an index whose first column is numeric (including date and time types),
and divides the column's range of values into chunks of approximately
\&\*(L"\-\-chunksize\*(R" rows.  Syncs a chunk at a time by checksumming the entire
chunk.  If the chunk differs on the source and destination, checksums each
chunk's rows individually to find the rows that differ.
.Sp
It is efficient when the column has sufficient cardinality to make the chunks
end up about the right size.
.Sp
The initial per-chunk checksum is quite small and results in minimal network
traffic and memory consumption.  If a chunk's rows must be examined, only the
primary key columns and a checksum are sent over the network, not the entire
row.  If a row is found to be different, the entire row will be fetched, but not
before.
.IP "Nibble" 4
.IX Item "Nibble"
Finds an index and ascends the index in fixed-size nibbles of \*(L"\-\-chunksize\*(R"
rows, using a non-backtracking algorithm (see mk-archiver for more on this
algorithm).  It is very similar to \*(L"Chunk\*(R", but instead of pre-calculating
the boundaries of each piece of the table based on index cardinality, it uses
\&\f(CW\*(C`LIMIT\*(C'\fR to define each nibble's upper limit, and the previous nibble's upper
limit to define the lower limit.
.Sp
It works in steps: one query finds the row that will define the next nibble's
upper boundary, and the next query checksums the entire nibble.  If the nibble
differs between the source and destination, it examines the nibble row\-by\-row,
just as \*(L"Chunk\*(R" does.
.IP "GroupBy" 4
.IX Item "GroupBy"
Selects the entire table grouped by all columns, with a \s-1COUNT\s0(*) column added.
Compares all columns, and if they're the same, compares the \s-1COUNT\s0(*) column's
value to determine how many rows to insert or delete into the destination.
Works on tables with no primary key or unique index.
.IP "Stream" 4
.IX Item "Stream"
Selects the entire table in one big stream and compares all columns.  Selects
all columns.  Much less efficient than the other algorithms, but works when
there is no suitable index for them to use.
.IP "Future Plans" 4
.IX Item "Future Plans"
Possibilities for future algorithms are TempTable (what I originally called
bottom-up in earlier versions of this tool), DrillDown (what I originallly
called top\-down), and GroupByPrefix (similar to how SqlYOG Job Agent works).
Each algorithm has strengths and weaknesses.  If you'd like to implement your
favorite technique for finding differences between two sources of data on
possibly different servers, I'm willing to help.  The algorithms adhere to a
simple interface that makes it pretty easy to write your own.
.SH "DOWNLOADING"
.IX Header "DOWNLOADING"
You can download Maatkit from Google Code at
<http://code.google.com/p/maatkit/>, or you can get any of the tools
easily with a command like the following:
.PP
.Vb 3
\&   wget http://www.maatkit.org/get/toolname
\&   or
\&   wget http://www.maatkit.org/trunk/toolname
.Ve
.PP
Where \f(CW\*(C`toolname\*(C'\fR can be replaced with the name (or fragment of a name) of any
of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
needed.  The first \s-1URL\s0 gets the latest released version of the tool, and the
second gets the latest trunk code from Subversion.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\-\-algorithm" 4
.IX Item "--algorithm"
short form: \-a; type: string
.Sp
The algorithm to use when comparing the tables.
.Sp
This is a suggestion.  The tool will auto-detect the best algorithm, and if your
chosen algorithm can't be used, will use the best available one instead.  See
\&\*(L"\s-1ALGORITHMS\s0\*(R".
.IP "\-\-askpass" 4
.IX Item "--askpass"
Prompt for a password when connecting to MySQL.
.IP "\-\-bufferresults" 4
.IX Item "--bufferresults"
Fetch all rows from MySQL before comparing.
.Sp
This is disabled by default.  If enabled, all rows will be fetched into memory
for comparing.  This may result in the results \*(L"cursor\*(R" being held open for a
shorter time on the server, but if the tables are large, it could take a long
time anyway, and eat all your memory.  For most non-trivial data sizes, you
want to leave this disabled.
.IP "\-\-bufferinmysql" 4
.IX Item "--bufferinmysql"
Instruct MySQL to buffer queries in its memory.
.Sp
This option adds the \f(CW\*(C`SQL_BUFFER_RESULT\*(C'\fR option to the comparison queries.
This causes MySQL to execute the queries and place them in a temporary table
internally before sending the results back to mk\-table\-sync.  The advantage of
this strategy is that mk-table-sync can fetch rows as desired without using a
lot of memory inside the Perl process, while releasing locks on the MySQL table
(to reduce contention with other queries).  The disadvantage is that it uses
more memory on the MySQL server instead.
.Sp
You probably want to enable \*(L"\-\-bufferresults\*(R" too, because buffering into a
temp table and then fetching it all into Perl's memory is probably a silly thing
to do.  This option is most useful for the GroupBy and Stream algorithms, which
may fetch a lot of data from the server.
.IP "\-\-chunksize" 4
.IX Item "--chunksize"
type: string; default: 1000
.Sp
Number of rows or data size per chunk.
.Sp
The size of each chunk of rows for the \*(L"Chunk\*(R" and \*(L"Nibble\*(R" algorithms.
The size can be either a number of rows, or a data size.  Data sizes are
specified with a suffix of k=kibibytes, M=mebibytes, G=gibibytes.  Data sizes
are converted to a number of rows by dividing by the average row length.
.IP "\-\-columns" 4
.IX Item "--columns"
short form: \-c; type: array
.Sp
Compare this comma-separated list of columns.
.IP "\-\-databases" 4
.IX Item "--databases"
short form: \-d; type: hash
.Sp
Sync only this comma-separated list of databases.
.IP "\-\-engine" 4
.IX Item "--engine"
short form: \-e; type: hash
.Sp
Sync only this comma-separated list of storage engines.
.IP "\-\-execute" 4
.IX Item "--execute"
short form: \-x
.Sp
Execute queries to make the tables have identical data.
.IP "\-\-function" 4
.IX Item "--function"
short form: \-f; type; string
.Sp
Which hash function you'd like to use for checksums.
.Sp
Good choices include \f(CW\*(C`MD5\*(C'\fR and \f(CW\*(C`SHA1\*(C'\fR.  If you have installed the \f(CW\*(C`FNV_64\*(C'\fR
user-defined function, \f(CW\*(C`mk\-table\-sync\*(C'\fR will detect it and prefer to use it,
because it is much faster than the others.  See mk-table-checksum for more
information and benchmarks.
.IP "\-\-ignoredb" 4
.IX Item "--ignoredb"
short form: \-g; type: Hash
.Sp
Ignore this comma-separated list of databases.
.IP "\-\-ignoreengine" 4
.IX Item "--ignoreengine"
short form: \-E; type: Hash; default: \s-1FEDERATED\s0,MRG_MyISAM
.Sp
Ignore this comma-separated list of storage engines.
.IP "\-\-ignoretbl" 4
.IX Item "--ignoretbl"
short form: \-n; type: Hash
.Sp
Ignore this comma-separated list of tables.
.Sp
Table names may be qualified with the database name.
.IP "\-\-lock" 4
.IX Item "--lock"
short form: \-k; type: int
.Sp
Lock tables: 0=none, 1=per sync cycle, 2=per table, or 3=globally.
.Sp
This uses \f(CW\*(C`LOCK TABLES\*(C'\fR.  This can help prevent tables being changed while
you're examining them.  The possible values are as follows:
.Sp
.Vb 12
\&  VALUE  MEANING
\&  =====  =======================================================
\&  0      Never lock tables.
\&  1      Lock and unlock one time per sync cycle (as implemented
\&         by the syncing algorithm).  This is the most granular
\&         level of locking available.  For example, the Chunk
\&         algorithm will lock each chunk of C<N> rows, and then
\&         unlock them if they are the same on the source and the
\&         destination, before moving on to the next chunk.
\&  2      Lock and unlock before and after each table.
\&  3      Lock and unlock once for every server (DSN) synced, with
\&         C<FLUSH TABLES WITH READ LOCK>.
.Ve
.Sp
A replication slave is never locked if \*(L"\-\-replicate\*(R" or \*(L"\-\-synctomaster\*(R"
is specified, since in theory locking the table on the master should prevent any
changes from taking place.  (You are not changing data on your slave, right?)
If \*(L"\-\-wait\*(R" is given, the master (source) is locked and then the tool waits
for the slave to catch up to the master before continuing.
.Sp
If \*(L"\-\-transaction\*(R" is specified, \f(CW\*(C`LOCK TABLES\*(C'\fR is not used.  Instead, lock
and unlock are implemented by beginning and committing transactions.  The exception
is if \*(L"\-\-lock\*(R" is 3.
.IP "\-\-print" 4
.IX Item "--print"
short form: \-p
.Sp
Print queries that will resolve differences.
.Sp
If you don't trust \f(CW\*(C`mk\-table\-sync\*(C'\fR, or just want to see what it will do, this
is a good way to be safe.  These queries are valid \s-1SQL\s0 and you can run them
yourself if you want to sync the tables manually.
.IP "\-\-replace" 4
.IX Item "--replace"
short form: \-r
.Sp
Write all \f(CW\*(C`INSERT\*(C'\fR and \f(CW\*(C`UPDATE\*(C'\fR statements as \f(CW\*(C`REPLACE\*(C'\fR.
.Sp
This is automatically switched on as needed when there are unique index
violations.
.IP "\-\-replicate" 4
.IX Item "--replicate"
short form: \-R; type: string
.Sp
Sync tables listed as different in this table.
.Sp
Specifies that \f(CW\*(C`mk\-table\-sync\*(C'\fR should examine the specified table to find data
that differs.  The table is exactly the same as the argument of the same name to
mk-table-checksum.  That is, it contains records of which tables (and ranges
of values) differ between the master and slave.
.Sp
For each table and range of values that shows differences between the master and
slave, \f(CW\*(C`mk\-table\-checksum\*(C'\fR will sync that table, with the appropriate \f(CW\*(C`WHERE\*(C'\fR
clause, to its master.
.Sp
This automatically sets \*(L"\-\-wait\*(R" to 60 and causes changes to be made on the
master instead of the slave.
.Sp
If \*(L"\-\-synctomaster\*(R" is specified, the tool will assume the server you
specified is the slave, and connect to the master as usual to sync.
.Sp
Otherwise, it will try to use \f(CW\*(C`SHOW PROCESSLIST\*(C'\fR to find slaves of the server
you specified.  If it is unable to find any slaves via \f(CW\*(C`SHOW PROCESSLIST\*(C'\fR, it
will inspect \f(CW\*(C`SHOW SLAVE HOSTS\*(C'\fR instead.  You must configure each slave's
\&\f(CW\*(C`report\-host\*(C'\fR, \f(CW\*(C`report\-port\*(C'\fR and other options for this to work right.  After
finding slaves, it will inspect the specified table on each slave to find data
that needs to be synced, and sync it. 
.Sp
The tool examines the master's copy of the table first, assuming that the master
is potentially a slave as well.  Any table that shows differences there will
\&\fB\s-1NOT\s0\fR be synced on the slave(s).  For example, suppose your replication is set
up as A\->B, B\->C, B\->D.  Suppose you use this argument and specify server B.
The tool will examine server B's copy of the table.  If it looks like server B's
data in table \f(CW\*(C`test.tbl1\*(C'\fR is different from server A's copy, the tool will not
sync that table on servers C and D.
.IP "\-\-setvars" 4
.IX Item "--setvars"
type: string; default: wait_timeout=10000 /*!40001 ,QUERY_CACHE_TYPE=0 */ 
.Sp
Set these MySQL variables.
.Sp
Specify any variables you want to be set immediately after connecting to MySQL.
These will be included in a \f(CW\*(C`SET\*(C'\fR command.
.IP "\-\-skipbinlog" 4
.IX Item "--skipbinlog"
Do not log to the binary log (\f(CW\*(C`SET SQL_LOG_BIN=0\*(C'\fR).
.IP "\-\-skipforeignkey" 4
.IX Item "--skipforeignkey"
short form: \-K
.Sp
Disable foreign key checks (\f(CW\*(C`SET FOREIGN_KEY_CHECKS=0\*(C'\fR).
.IP "\-\-skipslavecheck" 4
.IX Item "--skipslavecheck"
Don't check whether the destination server is a slave.
.Sp
If the destination server is a slave, it's generally unsafe to make changes on
it.  However, sometimes you have to; \*(L"\-\-replace\*(R" won't work unless there's a
unique index, for example, so you can't make changes on the master in that
scenario.  By default mk-table-sync will complain if you try to change data on a
slave.  This option will bypass that check.  Use it at your own risk.
.IP "\-\-skipuniquekey" 4
.IX Item "--skipuniquekey"
Disable unique index checks (\f(CW\*(C`SET UNIQUE_CHECKS=0\*(C'\fR).
.IP "\-\-synctomaster" 4
.IX Item "--synctomaster"
short form: \-s
.Sp
Treat the \s-1DSN\s0 as a slave and sync it to its master.
.Sp
Treat the server you specified as a slave.  Inspect \f(CW\*(C`SHOW SLAVE STATUS\*(C'\fR,
connect to the server's master, and treat the master as the source and the slave
as the destination.  Causes changes to be made on the master.  Sets \*(L"\-\-wait\*(R"
to 60 by default, sets \*(L"\-\-lock\*(R" to 1 by default, and disables
\&\*(L"\-\-transaction\*(R" by default.  See also \*(L"\-\-replicate\*(R", which changes this
option's behavior.
.IP "\-\-tables" 4
.IX Item "--tables"
short form: \-t; type: hash
.Sp
Sync only this comma-separated list of tables.
.Sp
Table names may be qualified with the database name.
.IP "\-\-test" 4
.IX Item "--test"
Analyze, decide the sync algorithm to use, print and exit.
.Sp
Implies \*(L"\-\-verbose\*(R" so you can see the results.
.IP "\-\-timeoutok" 4
.IX Item "--timeoutok"
Keep going if \*(L"\-\-wait\*(R" fails.
.Sp
If you specify \*(L"\-\-wait\*(R" and the slave doesn't catch up to the master's
position before the wait times out, the default behavior is to abort.  This
option makes the tool keep going anyway.  \fBWarning\fR: if you are trying to get a
consistent comparision between the two servers, you probably don't want to keep
going after a timeout.
.IP "\-\-transaction" 4
.IX Item "--transaction"
negatable: yes
.Sp
Use transactions instead of \f(CW\*(C`LOCK TABLES\*(C'\fR.
.Sp
The granularity of beginning and committing transactions is controlled by
\&\*(L"\-\-lock\*(R".  This is enabled by default, but since \*(L"\-\-lock\*(R" is disabled by
default, it has no effect.
.Sp
Most options that enable locking also disable transactions by default, so if
you want to use transactional locking (via \f(CW\*(C`LOCK IN SHARE MODE\*(C'\fR and \f(CW\*(C`FOR
UPDATE\*(C'\fR, you must specify \-\-transaction explicitly.
.Sp
If you don't specify \-\-transaction explicitly, \f(CW\*(C`mk\-table\-sync\*(C'\fR will decide on
a per-table basis whether to use transactions or table locks.  It currently
uses transactions on InnoDB tables, and table locks on all others.
.IP "\-\-trim" 4
.IX Item "--trim"
\&\s-1\fITRIM\s0()\fR> \f(CW\*(C`VARCHAR\*(C'\fR columns in \f(CW\*(C`BIT_XOR\*(C'\fR and \f(CW\*(C`ACCUM\*(C'\fR modes.  Helps when
comparing MySQL 4.1 to >= 5.0.
.Sp
This is useful when you don't care about the trailing space differences between
MySQL versions which vary in their handling of trailing spaces. MySQL 5.0 and 
later all retain trailing spaces in \f(CW\*(C`VARCHAR\*(C'\fR, while previous versions would 
remove them.
.IP "\-\-utf8" 4
.IX Item "--utf8"
negatable: yes; default: yes
.Sp
Enable \s-1UTF\-8\s0 options in Perl and MySQL.
.Sp
This option is deprecated.  Pass the \f(CW\*(C`A\*(C'\fR option in a \s-1DSN\s0 instead.  For
backwards compatibility, this option adds \f(CW\*(C`A=utf8\*(C'\fR to all DSNs.
.Sp
Enables character set settings in Perl and MySQL.  If the value is \f(CW\*(C`utf8\*(C'\fR, sets
Perl's binmode on \s-1STDOUT\s0 to utf8, passes the \f(CW\*(C`mysql_enable_utf8\*(C'\fR option to
DBD::mysql, and runs \f(CW\*(C`SET NAMES UTF8\*(C'\fR after connecting to MySQL.  Any other
value sets binmode on \s-1STDOUT\s0 without the utf8 layer, and runs \f(CW\*(C`SET NAMES\*(C'\fR after
connecting to MySQL.
.IP "\-\-verbose" 4
.IX Item "--verbose"
short form: \-v
.Sp
Print results of sync operations.
.Sp
See \*(L"\s-1OUTPUT\s0\*(R" for more details about the output.
.IP "\-\-wait" 4
.IX Item "--wait"
short form: \-w; type: time
.Sp
How long to wait for slaves to catch up to their master.
.Sp
Make the master wait for the slave to catch up in replication before comparing
the tables.  The value is the number of seconds to wait before timing out (see
also \*(L"\-\-timeoutok\*(R").  Sets \*(L"\-\-lock\*(R" to 1 and \*(L"\-\-transaction\*(R" to 0 by
default.
.IP "\-\-where" 4
.IX Item "--where"
short form: \-W; type: string
.Sp
\&\f(CW\*(C`WHERE\*(C'\fR clause to restrict syncing to part of the table.
.SH "EXIT STATUS"
.IX Header "EXIT STATUS"
Exit status is as follows:
.PP
.Vb 6
\&   STATUS  MEANING
\&   ======  =======================================================
\&   0       Success.
\&   1       Internal error.
\&   2       At least one table differed on the destination.
\&   3       Combination of 1 and 2.
.Ve
.SH "OUTPUT"
.IX Header "OUTPUT"
If you specify the \*(L"\-\-verbose\*(R" option, you'll see information about the 
differences between the tables.  There is one row per table.  Each server is
printed separately.  For example,
.PP
.Vb 3
\&   # Syncing D=test,t=test2
\&   # DELETE REPLACE INSERT UPDATE ALGORITHM DATABASE.TABLE
\&   #      0       0      2      0 Chunk     test.test1
.Ve
.PP
This table required 2 \f(CW\*(C`UPDATE\*(C'\fR statements to synchronize.
.PP
There are cases where no combination of \f(CW\*(C`INSERT\*(C'\fR, \f(CW\*(C`UPDATE\*(C'\fR or \f(CW\*(C`DELETE\*(C'\fR
statements can resolve differences without violating some unique key.  For
example, suppose there's a primary key on column a and a unique key on column b.
Then there is no way to sync these two tables with straightforward \s-1UPDATE\s0
statements:
.PP
.Vb 6
\& +\-\-\-+\-\-\-+  +\-\-\-+\-\-\-+
\& | a | b |  | a | b |
\& +\-\-\-+\-\-\-+  +\-\-\-+\-\-\-+
\& | 1 | 2 |  | 1 | 1 |
\& | 2 | 1 |  | 2 | 2 |
\& +\-\-\-+\-\-\-+  +\-\-\-+\-\-\-+
.Ve
.PP
The tool rewrites queries to \f(CW\*(C`DELETE\*(C'\fR and \f(CW\*(C`REPLACE\*(C'\fR in this case.  This is
automatically handled after the first index violation, so you don't have to
worry about it.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The environment variable \s-1MKDEBUG\s0 enables verbose debugging output in all of the
Maatkit tools:
.PP
.Vb 1
\&   MKDEBUG=1 mk\-....
.Ve
.SH "HISTORY AND ACKNOWLEDGEMENTS"
.IX Header "HISTORY AND ACKNOWLEDGEMENTS"
My work is based in part on Giuseppe Maxia's work on distributed databases,
<http://www.sysadminmag.com/articles/2004/0408/> and code derived from that
article.  There is more explanation, and a link to the code, at
<http://www.perlmonks.org/?node_id=381053>.
.PP
Another programmer extended Maxia's work even further.  Fabien Coelho changed
and generalized Maxia's technique, introducing symmetry and avoiding some
problems that might have caused too-frequent checksum collisions.  This work
grew into pg_comparator, <http://www.coelho.net/pg_comparator/>.  Coelho also
explained the technique further in a paper titled \*(L"Remote Comparison of Database
Tables\*(R" (<http://cri.ensmp.fr/classement/doc/A\-375.pdf>).
.PP
This existing literature mostly addressed how to find the differences between
the tables, not how to resolve them once found.  I needed a tool that would not
only find them efficiently, but would then resolve them.  I first began thinking
about how to improve the technique further with my article
<http://www.xaprb.com/blog/2007/03/05/an\-algorithm\-to\-find\-and\-resolve\-data\-differences\-between\-mysql\-tables/>,
where I discussed a number of problems with the Maxia/Coelho \*(L"bottom\-up\*(R"
algorithm.  After writing that article, I began to write this tool.  I wanted to
actually implement their algorithm with some improvements so I was sure I
understood it completely.  I discovered it is not what I thought it was, and is
considerably more complex than it appeared to me at first.  Fabien Coelho was
kind enough to address some questions over email.
.PP
The first versions of this tool implemented a version of the Coelho/Maxia
algorithm, which I called \*(L"bottom\-up\*(R", and my own, which I called \*(L"top\-down.\*(R"
Those algorithms are considerably more complex than the current algorithms and
I have removed them from this tool, and may add them back later.  The
improvements to the bottom-up algorithm are my original work, as is the
top-down algorithm.  The techniques to actually resolve the differences are
also my own work.
.PP
Another tool that can synchronize tables is the SQLyog Job Agent from webyog.
Thanks to Rohit Nadhani, \s-1SJA\s0's author, for the conversations about the general
techniques.  There is a comparison of mk-table-sync and \s-1SJA\s0 at
<http://www.xaprb.com/blog/2007/04/05/mysql\-table\-sync\-vs\-sqlyog\-job\-agent/>
.PP
Thanks to the following people and organizations for helping in many ways:
.PP
The Rimm-Kaufman Group <http://www.rimmkaufman.com/>,
MySQL \s-1AB\s0 <http://www.mysql.com/>,
Blue Ridge InternetWorks <http://www.briworks.com/>,
Percona <http://www.percona.com/>,
Fabien Coelho,
Giuseppe Maxia and others at MySQL \s-1AB\s0,
Kristian Koehntopp (MySQL \s-1AB\s0),
Rohit Nadhani (WebYog),
The helpful monks at Perlmonks,
And others too numerous to mention.
.SH "SYSTEM REQUIREMENTS"
.IX Header "SYSTEM REQUIREMENTS"
You need Perl, \s-1DBI\s0, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.
.SH "BUGS"
.IX Header "BUGS"
Please use Google Code Issues and Groups to report bugs or request support:
<http://code.google.com/p/maatkit/>.
.PP
Please include the complete command-line used to reproduce the problem you are
seeing, the version of all MySQL servers involved, the complete output of the
tool when run with \*(L"\-\-version\*(R", and if possible, debugging output produced by
running with the \f(CW\*(C`MKDEBUG=1\*(C'\fR environment variable.
.SH "COPYRIGHT, LICENSE AND WARRANTY"
.IX Header "COPYRIGHT, LICENSE AND WARRANTY"
This program is copyright (c) 2007 Baron Schwartz.
Feedback and improvements are welcome.
.PP
\&\s-1THIS\s0 \s-1PROGRAM\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1AND\s0 \s-1WITHOUT\s0 \s-1ANY\s0 \s-1EXPRESS\s0 \s-1OR\s0 \s-1IMPLIED\s0
\&\s-1WARRANTIES\s0, \s-1INCLUDING\s0, \s-1WITHOUT\s0 \s-1LIMITATION\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0
\&\s-1MERCHANTIBILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
.PP
This program is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 General Public License as published by the Free Software
Foundation, version 2; \s-1OR\s0 the Perl Artistic License.  On \s-1UNIX\s0 and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, \s-1MA\s0  02111\-1307  \s-1USA\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Baron Schwartz.
.SH "VERSION"
.IX Header "VERSION"
This manual page documents Ver 1.0.8 Distrib 2152 \f(CW$Revision:\fR 2146 $.
