.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MK-TABLE-CHECKSUM 1p"
.TH MK-TABLE-CHECKSUM 1p "2008-08-12" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
mk\-table\-checksum \- Perform an online replication consistency check, or
checksum MySQL tables efficiently on one or many servers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   mk\-table\-checksum \-\-replicate=mydb.checksum master\-host
\&   ... time passses, replication catches up ...
\&   mk\-table\-checksum \-\-replicate=mydb.checksum \-\-replcheck 2 master\-host
.Ve
.PP
Or,
.PP
.Vb 1
\&   mk\-table\-checksum h=host1,u=user,p=password h=host2 ...
.Ve
.PP
Or,
.PP
.Vb 1
\&   mk\-table\-checksum host1 host2 ... hostN | mk\-checksum\-filter
.Ve
.PP
See \*(L"\s-1SPECIFYING\s0 \s-1HOSTS\s0\*(R" for more on the syntax of the host arguments.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
mk-table-checksum generates table checksums for MySQL tables, typically
useful for verifying your slaves are in sync with the master.  The checksums
are generated by a query on the server, and there is very little network
traffic as a result.
.PP
Checksums typically take about twice as long as \s-1COUNT\s0(*) on very large InnoDB
tables in my tests.  For smaller tables, \s-1COUNT\s0(*) is a good bit faster than
the checksums.  See \*(L"\-\-algorithm\*(R" for more details on performance.
.PP
If you specify more than one server, mk-table-checksum assumes the first
server is the master and others are slaves.  Checksums are parallelized for
speed, forking off a child process for each table.  Duplicate server names are
ignored, but if you want to checksum a server against itself you can use two
different forms of the hostname (for example, \*(L"localhost 127.0.0.1\*(R", or
\&\*(L"h=localhost,P=3306 h=localhost,P=3307\*(R").
.PP
If you want to compare the tables in one database to those in another database
on the same server, just checksum both databases:
.PP
.Vb 1
\&   mk\-table\-checksum \-\-databases db1,db2
.Ve
.PP
You can then use mk-checksum-filter to compare the results in both databases
easily.
.PP
mk-table-checksum examines table structure only on the first host specified,
so if anything differs on the others, it won't notice.  It ignores views.
.PP
The checksums work on MySQL version 3.23.58 through 6.0\-alpha.  They will not
necessarily produce the same values on all versions.  Differences in
formatting and/or space-padding between 4.1 and 5.0, for example, will cause
the checksums to be different.
.SH "SPECIFYING HOSTS"
.IX Header "SPECIFYING HOSTS"
mk-table-checksum connects to a theoretically unlimited number of MySQL
servers.  You specify a list of one or more host definitions on the command
line, such as \*(L"host1 host2\*(R".  Each host definition can be just a hostname, or it
can be a complex string that specifies connection options as well.  You can
specify connection options two ways:
.IP "\(bu" 4
Format a host definition in a key=value,key=value form.  If an argument on the
command line contains the letter '=', mk-table-checksum will parse it into
its component parts.  Examine the \*(L"\-\-help\*(R" output for details on the allowed
keys.
.Sp
Specifying a list of simple host definitions \*(L"host1 host2\*(R" is equivalent to the
more complicated \*(L"h=host1 h=host2\*(R" format.
.IP "\(bu" 4
With the command-line options such as \*(L"\-\-user\*(R" and \*(L"\-\-password\*(R".  These
options, if given, apply globally to all host definitions.
.PP
In addition to specifying connection options this way, mk-table-checksum
allows shortcuts.  Any options specified for the first host definition on the
command line fill in missing values in subsequent ones.  Any options that are
still missing after this are filled in from the command-line options if
possible.
.PP
In other words, the places you specify connection options have precedence:
highest precedence is the option specified directly in the host definition, next
is the option specified in the first host definition, and lowest is the
command-line option.
.PP
You can mix simple and complex host definitions and/or command-line arguments.
For example, if all your servers except one of your slaves uses a non-standard
port number:
.PP
.Vb 1
\&   mk\-table\-checksum \-\-port 4500 master h=slave1,P=3306 slave2 slave3
.Ve
.PP
If you are confused about how mk-table-checksum will connect to your servers,
give the \*(L"\-\-explainhosts\*(R" option and it will tell you.
.SH "HOW FAST IS IT?"
.IX Header "HOW FAST IS IT?"
Speed and efficiency are important, because the typical use case is checksumming
large amounts of data.
.PP
\&\f(CW\*(C`mk\-table\-checksum\*(C'\fR is designed to do very little work itself, and generates
very little network traffic aside from inspecting table structures with \f(CW\*(C`SHOW
CREATE TABLE\*(C'\fR.  The results of checksum queries are typically 40\-character or
shorter strings.
.PP
The MySQL server does the bulk of the work, in the form of the checksum queries.
The following benchmarks show the checksum query times for various checksum
algorithms.  The first two results are simply running \f(CW\*(C`COUNT(col8)\*(C'\fR and
\&\f(CW\*(C`CHECKSUM TABLE\*(C'\fR on the table.
.PP
.Vb 12
\& ALGORITHM       HASH FUNCTION  EXTRA      TIME
\& ==============  =============  ========  =====
\& COUNT(col8)                                2.3
\& CHECKSUM TABLE                             5.3
\& BIT_XOR         FNV_64                    12.7
\& ACCUM           FNV_64                    42.4
\& BIT_XOR         MD5            \-\-optxor   80.0
\& ACCUM           MD5                       87.4
\& BIT_XOR         SHA1           \-\-optxor   90.1
\& ACCUM           SHA1                     101.3
\& BIT_XOR         MD5                      172.0
\& BIT_XOR         SHA1                     197.3
.Ve
.PP
The tests are entirely CPU\-bound.  The sample data is an InnoDB table with the
following structure:
.PP
.Vb 13
\& CREATE TABLE test (
\&   col1 int NOT NULL,
\&   col2 date NOT NULL,
\&   col3 int NOT NULL,
\&   col4 int NOT NULL,
\&   col5 int,
\&   col6 decimal(3,1),
\&   col7 smallint unsigned NOT NULL,
\&   col8 timestamp NOT NULL,
\&   PRIMARY KEY  (col2, col1),
\&   KEY (col7),
\&   KEY (col1)
\& ) ENGINE=InnoDB
.Ve
.PP
The table has 4303585 rows, 365969408 bytes of data and 173457408 bytes of
indexes.  The server is a Dell PowerEdge 1800 with dual 32\-bit Xeon 2.8GHz
processors and 2GB of \s-1RAM\s0.  The tests are fully CPU\-bound, and the server is
otherwise idle.  The results are generally consistent to within a tenth of a
second on repeated runs.
.SH "DOWNLOADING"
.IX Header "DOWNLOADING"
You can download Maatkit from Google Code at
<http://code.google.com/p/maatkit/>, or you can get any of the tools
easily with a command like the following:
.PP
.Vb 3
\&   wget http://www.maatkit.org/get/toolname
\&   or
\&   wget http://www.maatkit.org/trunk/toolname
.Ve
.PP
Where \f(CW\*(C`toolname\*(C'\fR can be replaced with the name (or fragment of a name) of any
of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
needed.  The first \s-1URL\s0 gets the latest released version of the tool, and the
second gets the latest trunk code from Subversion.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\-\-algorithm" 4
.IX Item "--algorithm"
short form: \-a; type: string
.Sp
Checksum algorithm (ACCUM|CHECKSUM|BIT_XOR).
.Sp
Specifies which checksum algorithm to use.  Valid arguments are \s-1CHECKSUM\s0,
\&\s-1BIT_XOR\s0 and \s-1ACCUM\s0.  The latter two do cryptographic hash checksums.
.Sp
\&\s-1CHECKSUM\s0 is built into MySQL, but has some disadvantages.  \s-1BIT_XOR\s0 and \s-1ACCUM\s0 are
implemented by \s-1SQL\s0 queries.  They use a cryptographic hash of all columns
concatenated together with a separator, followed by a bitmap of each nullable
column that is \s-1NULL\s0 (necessary because \s-1\fICONCAT_WS\s0()\fR skips \s-1NULL\s0 columns).
.Sp
\&\s-1CHECKSUM\s0 is the default.  This method uses MySQL's built-in \s-1CHECKSUM\s0 \s-1TABLE\s0
command, which is a \s-1CRC32\s0 behind the scenes.  It cannot be used before MySQL
4.1.1, and various options disable it as well.  It does not simultaneously count
rows; that requires an extra \s-1COUNT\s0(*) query.  This is a good option when you are
using MyISAM tables with live checksums enabled; in this case both the \s-1COUNT\s0(*)
and \s-1CHECKSUM\s0 queries will run very quickly.
.Sp
The \s-1BIT_XOR\s0 algorithm is available for MySQL 4.1.1 and newer.  It uses
\&\s-1\fIBIT_XOR\s0()\fR, which is order\-independent, to reduce all the rows to a single
checksum.
.Sp
\&\s-1ACCUM\s0 uses a user variable as an accumulator.  It reduces each row to a single
checksum, which is concatenated with the accumulator and re\-checksummed.  This
technique is order\-dependent.  If the table has a primary key, it will be used
to order the results for consistency; otherwise it's up to chance.
.Sp
The pathological worst case is where identical rows will cancel each other out
in the \s-1BIT_XOR\s0.  In this case you will not be able to distinguish a table full
of one value from a table full of another value.  The \s-1ACCUM\s0 algorithm will
distinguish them.
.Sp
However, the \s-1ACCUM\s0 algorithm is order\-dependent, so if you have two tables
with identical data but the rows are out of order, you'll get different
checksums with \s-1ACCUM\s0.
.Sp
If a given algorithm won't work for some reason, mk-table-checksum falls back to
another.  The least common denominator is \s-1ACCUM\s0, which works on MySQL 3.23.2 and
newer.
.IP "\-\-askpass" 4
.IX Item "--askpass"
Prompt for a password when connecting to MySQL.
.IP "\-\-checksum" 4
.IX Item "--checksum"
Print checksums and table names in the style of md5sum (disables \*(L"\-\-count\*(R").
.Sp
Makes the output behave more like the output of \f(CW\*(C`md5sum\*(C'\fR.  The checksum is
first on the line, followed by the host, database, table, and chunk number,
concatenated with dots.
.IP "\-\-chunksize" 4
.IX Item "--chunksize"
short form: \-C; type: string
.Sp
Approximate number of rows or size of data to checksum at a time.  Allowable
suffixes are k, M, G. Disallows \-a \s-1CHECKSUM\s0.
.Sp
If you specify a chunk size, mk-table-checksum will try to find an index that
will let it split the table into ranges of approximately \*(L"\-\-chunksize\*(R"
rows, based on the table's index statistics.  It will checksum each range
separately with parameters in the checksum query's \s-1WHERE\s0 clause.
.Sp
If mk-table-checksum cannot find a suitable index, it will do the entire
table in one chunk as though you had not specified \*(L"\-\-chunksize\*(R" at all.
Each table is handled individually, so some tables may be chunked and others
not.
.Sp
The chunks will be approximately sized, and depending on the distribution of
values in the indexed column, some chunks may be larger than the value you
specify.
.Sp
If you specify a suffix (one of k, M or G), the parameter is treated as a data
size rather than a number of rows.  The output of \s-1SHOW\s0 \s-1TABLE\s0 \s-1STATUS\s0 is then used
to estimate the amount of data the table contains, and convert that to a number
of rows.
.IP "\-\-columns" 4
.IX Item "--columns"
type: array
.Sp
Checksum only this comma-separated list of columns.
.IP "\-\-count" 4
.IX Item "--count"
short form: \-r; negatable: yes
.Sp
Count rows in tables.  This is built into \s-1ACCUM\s0 and \s-1BIT_XOR\s0, but requires an
extra query for \s-1CHECKSUM\s0.
.Sp
This is disabled by default to avoid an extra \s-1COUNT\s0(*) query when
\&\*(L"\-\-algorithm\*(R" is \s-1CHECKSUM\s0.  If you have only MyISAM tables and live checksums
are enabled, both \s-1CHECKSUM\s0 and \s-1COUNT\s0 will be very fast, but otherwise you may
want to use one of the other algorithms.
.IP "\-\-crc" 4
.IX Item "--crc"
short form: \-c; negatable: yes; default: yes
.Sp
Do a \s-1CRC\s0 (checksum) of tables.
.Sp
Take the checksum of the rows as well as their count.  This is enabled by
default.  If you disable it, you'll just get \s-1COUNT\s0(*) queries.
.IP "\-\-databases" 4
.IX Item "--databases"
short form: \-d; type: hash
.Sp
Only checksum this comma-separated list of databases.
.IP "\-\-defaults\-file" 4
.IX Item "--defaults-file"
short form: \-F; type: string
.Sp
Only read mysql options from the given file.  You must give an absolute
pathname.
.IP "\-\-emptyrepltbl" 4
.IX Item "--emptyrepltbl"
Empty table given by \*(L"\-\-replicate\*(R" before starting.
.Sp
Issues a \s-1DELETE\s0 against the table given by \*(L"\-\-replicate\*(R" before beginning
work.  Ignored if \*(L"\-\-replicate\*(R" is not specified.  This can be useful to
remove entries related to tables that no longer exist, or just to clean out the
results of a previous run.
.Sp
If you specify any options that filter databases or tables, \f(CW\*(C`mk\-table\-checksum\*(C'\fR
will remove only their entries.  Otherwise, it empties the entire table.
.IP "\-\-engine" 4
.IX Item "--engine"
short form: \-e; type: hash
.Sp
Do only this comma-separated list of storage engines.
.IP "\-\-explain" 4
.IX Item "--explain"
Show, but do not execute, checksum queries (disables \*(L"\-\-emptyrepltbl\*(R").
.IP "\-\-explainhosts" 4
.IX Item "--explainhosts"
Print connection information and exit.
.Sp
Print out a list of hosts to which mk-table-checksum will connect, with all
the various connection options, and exit.  See \*(L"\s-1SPECIFYING\s0 \s-1HOSTS\s0\*(R".
.IP "\-\-float\-precision" 4
.IX Item "--float-precision"
type: int
.Sp
Precision for \f(CW\*(C`FLOAT\*(C'\fR and \f(CW\*(C`DOUBLE\*(C'\fR column comparisons.
.Sp
If you specify this option, \s-1FLOAT\s0 and \s-1DOUBLE\s0 columns will be rounded to the
specified number of digits after the decimal point for the checksum.  This can
avoid checksum mismatches due to different floating-point representations of
the same values on different MySQL versions and hardware.
.IP "\-\-function" 4
.IX Item "--function"
short form: \-f; type: string
.Sp
Hash function for checksums (\s-1FNV_64\s0, \s-1SHA1\s0, \s-1MD5\s0, etc).
.Sp
You can use this option to choose the cryptographic hash function used for
\&\*(L"\-\-algorithm\*(R"=ACCUM or \*(L"\-\-algorithm\*(R"=BIT_XOR.  The default is to use
\&\f(CW\*(C`MD5\*(C'\fR, but \f(CW\*(C`SHA1\*(C'\fR also works, and you can use your own function, such as a
compiled \s-1UDF\s0, if you wish.  Whatever function you specify is run in \s-1SQL\s0, not in
Perl, so it must be available to MySQL.
.Sp
The \f(CW\*(C`FNV_64\*(C'\fR \s-1UDF\s0 mentioned in the benchmarks is much faster than \f(CW\*(C`MD5\*(C'\fR.  The
\&\*(C+ source code is distributed with Maatkit.  It is very simple to compile and
install; look at the header in the source code for instructions.  If it is
installed, it is the default.
.IP "\-\-ignoredb" 4
.IX Item "--ignoredb"
short form: \-g; type: Hash
.Sp
Ignore this comma-separated list of databases.
.IP "\-\-ignoreengine" 4
.IX Item "--ignoreengine"
short form: \-E; type: Hash; default: \s-1FEDERATED\s0,MRG_MyISAM
.Sp
Ignore this comma-separated list of storage engines.
.IP "\-\-ignoretbl" 4
.IX Item "--ignoretbl"
short form: \-n; type: Hash
.Sp
Ignore this comma-separated list of tables.
.Sp
Table names may be qualified with the database name.
.IP "\-\-lock" 4
.IX Item "--lock"
short form: \-k
.Sp
Lock on master until done on slaves (implies \*(L"\-\-slavelag\*(R").
.Sp
This option can help you to get a consistent read on a master and many slaves.
If you specify this option, mk-table-checksum will lock the table on the
first server on the command line, which it assumes to be the master.  It will
keep this lock until the checksums complete on the other servers.
.Sp
This option isn't very useful by itself, so you probably want to use \*(L"\-\-wait\*(R"
instead.
.IP "\-\-optxor" 4
.IX Item "--optxor"
short form: \-o; default: yes; negatable: yes
.Sp
Optimize \s-1BIT_XOR\s0 with user variables.
.Sp
This option specifies to use user variables to reduce the number of times each
row must be passed through the cryptographic hash function when you are using
the \s-1BIT_XOR\s0 algorithm.
.Sp
With the optimization, the queries look like this in pseudo\-code:
.Sp
.Vb 5
\&  SELECT CONCAT(
\&     BIT_XOR(SLICE_OF(@user_variable)),
\&     BIT_XOR(SLICE_OF(@user_variable)),
\&     ...
\&     BIT_XOR(SLICE_OF(@user_variable := HASH(col1, col2... colN))));
.Ve
.Sp
The exact positioning of user variables and calls to the hash function is
determined dynamically, and will vary between MySQL versions.  Without the
optimization, it looks like this:
.Sp
.Vb 5
\&  SELECT CONCAT(
\&     BIT_XOR(SLICE_OF(MD5(col1, col2... colN))),
\&     BIT_XOR(SLICE_OF(MD5(col1, col2... colN))),
\&     ...
\&     BIT_XOR(SLICE_OF(MD5(col1, col2... colN))));
.Ve
.Sp
The difference is the number of times all the columns must be mashed together
and fed through the hash function.  If you are checksumming really large
columns, such as \s-1BLOB\s0 or \s-1TEXT\s0 columns, this might make a big difference.
.IP "\-\-password" 4
.IX Item "--password"
short form: \-p; type: string
.Sp
Password to use when connecting.
.IP "\-\-port" 4
.IX Item "--port"
short form: \-P; type: int
.Sp
Port number to use for connection.
.IP "\-\-quiet" 4
.IX Item "--quiet"
short form: \-q
.Sp
Do not print checksum results.
.IP "\-\-replcheck" 4
.IX Item "--replcheck"
type: int
.Sp
Check results in \*(L"\-\-replicate\*(R" table, to the specified depth.
.Sp
Recursively finds differences recorded in the table given by \*(L"\-\-replicate\*(R".
Recurses to the depth you specify: 0 is no recursion (check only the server
you specify), 1 is check the server and its slaves, 2 is check the slaves of
its slaves, and so on.
.Sp
It finds differences by running the query shown in \*(L"\s-1CONSISTENT\s0 \s-1CHECKSUMS\s0\*(R",
and prints results.  Exits after printing.  This is just a convenient way of
running the query so you don't have to do it manually.
.Sp
The output is one informational line per slave host, followed by the results
of the query, if any.  If \*(L"\-\-quiet\*(R" is specified, there is no output.
.Sp
This option makes \f(CW\*(C`mk\-table\-checksum\*(C'\fR looks for slaves by running \f(CW\*(C`SHOW
PROCESSLIST\*(C'\fR.  If it finds connections that appear to be from slaves, it derives
connection information for each slave the same default-and-override method
described in \*(L"\s-1SPECIFYING\s0 \s-1HOSTS\s0\*(R".
.Sp
If \f(CW\*(C`SHOW PROCESSLIST\*(C'\fR doesn't return any rows, \f(CW\*(C`mk\-table\-checksum\*(C'\fR looks at
\&\f(CW\*(C`SHOW SLAVE HOSTS\*(C'\fR instead.  The host and port, and user and password if
available, from \f(CW\*(C`SHOW SLAVE HOSTS\*(C'\fR are combined into a \s-1DSN\s0 and used as the
argument.  This requires slaves to be configured with \f(CW\*(C`report\-host\*(C'\fR,
\&\f(CW\*(C`report\-port\*(C'\fR and so on.
.Sp
This requires the @@SERVER_ID system variable, so it works only on MySQL
3.23.26 or newer.
.Sp
If any slave has chunks that differ from the master, mk\-table\-checksum's
exit status is 1; otherwise it is 0.
.IP "\-\-replicate" 4
.IX Item "--replicate"
short form: \-R; type: string
.Sp
Replicate checksums to slaves (disallows \-a \s-1CHECKSUM\s0).
.Sp
This option enables a completely different checksum strategy for a consistent,
lock-free checksum across a master and its slaves.  This works only with
statement-based replication (mk\-table\-checksum will switch the binlog format
to \s-1STATEMENT\s0 for the duration of the session if your server uses row-based
replication).  Instead of running the checksum queries on each server, you run
it only on the master.  You specify a table to insert the results into.  The
query will insert directly into the table, so it will be replicated through the
binlog to the slaves.
.Sp
The argument to the option is the table in which the checksums should be stored.
The table must have at least these columns: db, tbl, chunk, boundaries,
this_crc, master_crc, this_cnt, master_cnt.  Here is a suggested table
structure:
.Sp
.Vb 12
\&  CREATE TABLE checksum (
\&     db         char(64)     NOT NULL,
\&     tbl        char(64)     NOT NULL,
\&     chunk      int          NOT NULL,
\&     boundaries char(64)     NOT NULL,
\&     this_crc   char(40)     NOT NULL,
\&     this_cnt   int          NOT NULL,
\&     master_crc char(40)         NULL,
\&     master_cnt int              NULL,
\&     ts         timestamp    NOT NULL,
\&     PRIMARY KEY (db, tbl, chunk)
\&  );
.Ve
.Sp
Be sure to choose an appropriate storage engine for the checksum table.  If you
are checksumming InnoDB tables, for instance, a deadlock will break replication
if the checksum table is non\-transactional, because the transaction will still
be written to the binlog.  It will then replay without a deadlock on the
slave and break replication with \*(L"different error on master and slave.\*(R"  This
is not a problem with mk\-table\-checksum, it's a problem with MySQL
replication, and you can read more about it in the MySQL manual.
.Sp
When the queries are finished replicating, you can run a simple query on each
slave to see which tables have differences from the master.  See \*(L"\s-1CONSISTENT\s0 \s-1CHECKSUMS\s0\*(R" for details.  If you find tables that have differences, you can use
the chunk boundaries in a \s-1WHERE\s0 clause to mk-table-sync to help repair
them more efficiently.  See mk-table-sync for details.
.Sp
This option eliminates the need to do complicated locking and unlocking, waiting
for master binlog positions, and so on.  It disables \*(L"\-\-lock\*(R", \*(L"\-\-wait\*(R",
and \*(L"\-\-slavelag\*(R".
.Sp
The checksum queries actually do a \s-1REPLACE\s0 into this table, so existing rows
need not be removed before running.  However, you may wish to do this anyway to
remove rows related to tables that don't exist anymore.  The \*(L"\-\-emptyrepltbl\*(R"
option does this for you.
.Sp
Since mk-table-checksum uses \s-1USE\s0 to select the table's database as its
default database before executing the checksum query, the checksum queries
should replicate to slaves even if \-\-binlog\-do\-db settings on the master filter
out the checksum table's database.  For more information on how \-\-binlog\-do\-db
works, see <http://dev.mysql.com/doc/en/binary\-log.html>.
.Sp
If the slaves have any \-\-replicate\-do\-X or replicate-ignore-X options, you
should be careful not to checksum any databases or tables that exist on the
master and not the slaves.  Changes to such tables may not normally be executed
on the slaves because of the \-\-replicate\-X options, but the checksum queries
change the checksum table, not the tables they checksum.  Therefore these
queries will be executed on the slave, and if the table or database does not
exist, they will cause replication to fail.  For more information on replication
rules, see <http://dev.mysql.com/doc/en/replication\-rules.html>.
.Sp
The table specified by \*(L"\-\-replicate\*(R" will never be checksummed itself.
.IP "\-\-separator" 4
.IX Item "--separator"
short form: \-s; type: string; default: #
.Sp
The separator character used for \s-1\fICONCAT_WS\s0()\fR.
.IP "\-\-setvars" 4
.IX Item "--setvars"
type: string; default: wait_timeout=10000
.Sp
Set these MySQL variables.
.Sp
Specify any variables you want to be set immediately after connecting to MySQL.
These will be included in a \f(CW\*(C`SET\*(C'\fR command.
.IP "\-\-slavelag" 4
.IX Item "--slavelag"
short form: \-l
.Sp
Report how far slaves lag master.
.Sp
If this option is enabled, the output will show how many seconds behind the
master each slave is.  This can be useful when you want a fast, parallel,
non-blocking checksum, and you know your slaves might lag the master.  You can
inspect the results and make an educated guess whether any discrepancies on the
slave are due to slave lag instead of corrupt data.
.IP "\-\-sleep" 4
.IX Item "--sleep"
type: int
.Sp
Sleep time between checksums.
.Sp
If this option is specified, mk-table-checksum will sleep the specified
number of seconds between checksums.  That is, it will sleep between every
table, and if you specify \*(L"\-\-chunksize\*(R", it will also sleep between chunks.
.IP "\-\-sleep\-coef" 4
.IX Item "--sleep-coef"
type: float
.Sp
Calculate \*(L"\-\-sleep\*(R" as a multiple of the last checksum time.
.Sp
If this option is specified, mk-table-checksum will sleep the amount of
time elapsed during the previous checksum, multiplied by the specified
coefficient.  This option is ignored if \*(L"\-\-sleep\*(R" is specified.
.IP "\-\-socket" 4
.IX Item "--socket"
short form: \-S; type: string
.Sp
Socket file to use for connection.
.IP "\-\-tab" 4
.IX Item "--tab"
short form: \-b
.Sp
Print tab-separated output, not column-aligned output.
.IP "\-\-tables" 4
.IX Item "--tables"
short form: \-t; type: hash
.Sp
Do only this comma-separated list of tables.
.Sp
Table names may be qualified with the database name.
.IP "\-\-trim" 4
.IX Item "--trim"
Trim \f(CW\*(C`VARCHAR\*(C'\fR columns (helps when comparing 4.1 to >= 5.0).
.Sp
This option adds a \f(CW\*(C`TRIM()\*(C'\fR to \f(CW\*(C`VARCHAR\*(C'\fR columns in \f(CW\*(C`BIT_XOR\*(C'\fR and \f(CW\*(C`ACCUM\*(C'\fR
modes.
.Sp
This is useful when you don't care about the trailing space differences between
MySQL versions which vary in their handling of trailing spaces. MySQL 5.0 and 
later all retain trailing spaces in \f(CW\*(C`VARCHAR\*(C'\fR, while previous versions would 
remove them.
.IP "\-\-user" 4
.IX Item "--user"
short form: \-u; type: string
.Sp
User for login if not current user.
.IP "\-\-verify" 4
.IX Item "--verify"
short form: \-v; negatable: yes; default: yes
.Sp
Verify checksum compatibility across servers.
.Sp
This option runs a trivial checksum on all servers to ensure they have
compatible \s-1\fICONCAT_WS\s0()\fR and cryptographic hash functions.
.Sp
Versions of MySQL before 4.0.14 will skip empty strings and NULLs in
\&\s-1CONCAT_WS\s0, and others will only skip NULLs.  The two kinds of behavior will
produce different results if you have any columns containing the empty string
in your table.  If you know you don't (for instance, all columns are
integers), you can safely disable this check and you will get a reliable
checksum even on servers with different behavior.
.IP "\-\-wait" 4
.IX Item "--wait"
short form: \-w; type: time
.Sp
Wait this long for slaves to catch up to their master (implies \*(L"\-\-lock\*(R"
\&\*(L"\-\-slavelag\*(R").
.Sp
This option helps you get a consistent checksum across a master server and its
slaves.  It combines locking and waiting to accomplish this.  First it locks the
table on the master (the first server on the command line).  Then it finds the
master's binlog position.  Checksums on slaves will be deferred until they reach
the same binlog position.
.Sp
The argument to the option is the number of seconds to wait for the slaves to
catch up to the master.  It is actually the argument to \s-1\fIMASTER_POS_WAIT\s0()\fR.  If
the slaves don't catch up to the master within this time, they will unblock
and go ahead with the checksum.  You can tell whether this happened by
examining the \s-1STAT\s0 column in the output, which is the return value of
\&\s-1\fIMASTER_POS_WAIT\s0()\fR.
.IP "\-\-where" 4
.IX Item "--where"
short form: \-W; type: string
.Sp
Do only rows matching this \f(CW\*(C`WHERE\*(C'\fR clause (disallows \*(L"\-\-algorithm\*(R" \s-1CHECKSUM\s0).
.Sp
You can use this option to limit the checksum to only part of the table.  This
is particularly useful if you have append-only tables and don't want to
constantly re-check all rows; you could run a daily job to just check
yesterday's rows, for instance.
.Sp
This option is much like the \-w option to mysqldump.  Do not specify the \s-1WHERE\s0
keyword.  You may need to quote the value.  Here is an example:
.Sp
.Vb 1
\&  mk\-table\-checksum \-\-where "foo=bar"
.Ve
.SH "CONSISTENT CHECKSUMS"
.IX Header "CONSISTENT CHECKSUMS"
If you are using this tool to verify your slaves still have the same data as the
master, which is why I wrote it, you should read this section.
.PP
The best way to do this with replication is to use the \*(L"\-\-replicate\*(R" option.
When the queries are finished running on the master and its slaves, you can go
to the slaves and issue \s-1SQL\s0 queries to see if any tables are different from the
master.  Try the following:
.PP
.Vb 6
\&  SELECT db, tbl, chunk, this_cnt\-master_cnt AS cnt_diff,
\&     this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc)
\&        AS crc_diff
\&  FROM checksum
\&  WHERE master_cnt <> this_cnt OR master_crc <> this_crc
\&     OR ISNULL(master_crc) <> ISNULL(this_crc);
.Ve
.PP
The \*(L"\-\-replcheck\*(R" option can do this query for you.  If you can't use this
method, try the following:
.IP "\(bu" 4
If your servers are not being written to, you can just run the tool with no
further ado:
.Sp
.Vb 1
\&  mk\-table\-checksum server1 server2 ... serverN
.Ve
.IP "\(bu" 4
If the servers are being written to, you need some way to make sure they are
consistent at the moment you run the checksums.  For situations other than
master-slave replication, you will have to figure this out yourself.  You may be
able to use the \*(L"\-\-where\*(R" option with a date or time column to only checksum
data that's not recent.
.IP "\(bu" 4
If you are checksumming a master and slaves, you can do a fast parallel
checksum and assume the slaves are caught up to the master.  In practice, this
tends to work well except for tables which are constantly updated.  You can
use the \*(L"\-\-slavelag\*(R" option to see how far behind each slave was when it
checksummed a given table.  This can help you decide whether to investigate
further.
.IP "\(bu" 4
The next most disruptive technique is to lock the table on the master, then take
checksums.  This should prevent changes from propagating to the slaves.  You can
just lock on the master (with \*(L"\-\-lock\*(R"), or you can both lock on the master
and wait on the slaves till they reach that point in the master's binlog
(\*(L"\-\-wait\*(R").  Which is better depends on your workload; only you know that.
.IP "\(bu" 4
If you decide to make the checksums on the slaves wait until they're guaranteed
to be caught up to the master, the algorithm looks like this:
.Sp
.Vb 9
\& For each table,
\&   Master: lock table
\&   Master: get pos
\&   In parallel,
\&     Master: checksum
\&     Slave(s): wait for pos, then checksum
\&   End
\&   Master: unlock table
\& End
.Ve
.PP
What I typically do when I'm not using the \*(L"\-\-replicate\*(R" option is simply run
the tool on all servers with no further options.  This runs fast, parallel,
non-blocking checksums simultaneously.  If there are tables that look different,
I re-run with \*(L"\-\-wait\*(R"=600 on the tables in question.  This makes the tool
lock on the master as explained above.
.SH "OUTPUT"
.IX Header "OUTPUT"
Output is to \s-1STDOUT\s0, one line per server and table, with header lines for each
database.  I tried to make the output easy to process with awk.  For this reason
columns are always present.  If there's no value, mk-table-checksum prints
\&'\s-1NULL\s0'.
.PP
The default is column-aligned output for human readability, but you can change
it to tab-separated if you want.  Use the \*(L"\-\-tab\*(R" option for this.
.PP
Output is unsorted, though all lines for one table should be output together.
For speed, all checksums are done in parallel (as much as possible) and may
complete out of the order in which they were started.  You might want to run
them through another script or command-line utility to make sure they are in the
order you want.  If you pipe the output through mk-checksum-filter, you
can sort the output and/or avoid seeing output about tables that have no
differences.
.PP
The columns in the output are as follows.  The database, table, and chunk come
first so you can sort by them easily (they are the \*(L"primary key\*(R").
.PP
Output from \*(L"\-\-replcheck\*(R" and \*(L"\-\-checksum\*(R" are different.
.IP "\s-1DATABASE\s0" 4
.IX Item "DATABASE"
The database the table is in.
.IP "\s-1TABLE\s0" 4
.IX Item "TABLE"
The table name.
.IP "\s-1CHUNK\s0" 4
.IX Item "CHUNK"
The chunk (see \*(L"\-\-chunksize\*(R").  Zero if you are not doing chunked checksums.
.IP "\s-1HOST\s0" 4
.IX Item "HOST"
The server's hostname.
.IP "\s-1ENGINE\s0" 4
.IX Item "ENGINE"
The table's storage engine.
.IP "\s-1COUNT\s0" 4
.IX Item "COUNT"
The table's row count, unless you specified to skip it.
.IP "\s-1CHECKSUM\s0" 4
.IX Item "CHECKSUM"
The table's checksum, unless you specifed to skip it or the table has no rows.
some types of checksums will be 0 if there are no rows; others will print \s-1NULL\s0.
.IP "\s-1TIME\s0" 4
.IX Item "TIME"
The time the actual checksum and/or counting took.
.IP "\s-1WAIT\s0" 4
.IX Item "WAIT"
How long the checksum blocked before beginning.
.IP "\s-1STAT\s0" 4
.IX Item "STAT"
The return value of \s-1\fIMASTER_POS_WAIT\s0()\fR.
.IP "\s-1LAG\s0" 4
.IX Item "LAG"
How far the slave lags the master, as reported by \s-1SHOW\s0 \s-1SLAVE\s0 \s-1STATUS\s0.
.SH "EXIT STATUS"
.IX Header "EXIT STATUS"
A successful exit status is 0.  If there is an error checksumming any table,
the exit status is 1.
.PP
When running \*(L"\-\-replcheck\*(R", if any slave has chunks that differ from the
master, the exit status is 1.
.SH "QUERIES"
.IX Header "QUERIES"
If you are using innotop (see <http://innotop.sourceforge.net/>),
mytop, or another tool to watch currently running MySQL queries, you may see
the checksum queries.  They look similar to this:
.PP
.Vb 1
\&  REPLACE /*test.test_tbl:'2'/'5'*/ INTO test.checksum(db, ...
.Ve
.PP
Since mk\-table\-checksum's queries run for a long time and tend to be
textually very long, and thus won't fit on one screen of these monitoring
tools, I've been careful to place a comment at the beginning of the query so
you can see what it is and what it's doing.  The comment contains the name of
the table that's being checksummed, the chunk it is currently checksumming,
and how many chunks will be checksummed.  In the case above, it is
checksumming chunk 2 of 5 in table test.test_tbl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See also mk-checksum-filter and mk-table-sync.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The environment variable \f(CW\*(C`MKDEBUG\*(C'\fR enables verbose debugging output in all of
the Maatkit tools:
.PP
.Vb 1
\&   MKDEBUG=1 mk\-....
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please use Google Code Issues and Groups to report bugs or request support:
<http://code.google.com/p/maatkit/>.
.PP
Please include the complete command-line used to reproduce the problem you are
seeing, the version of all MySQL servers involved, the complete output of the
tool when run with \*(L"\-\-version\*(R", and if possible, debugging output produced by
running with the \f(CW\*(C`MKDEBUG=1\*(C'\fR environment variable.
.SH "SYSTEM REQUIREMENTS"
.IX Header "SYSTEM REQUIREMENTS"
You need Perl, \s-1DBI\s0, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.
.SH "AUTHOR"
.IX Header "AUTHOR"
Baron \*(L"Xaprb\*(R" Schwartz.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
This is an incomplete list.  My apologies for omissions or misspellings.
.PP
Claus Jeppesen,
Francois Saint\-Jacques,
Giuseppe Maxia,
Heikki Tuuri,
James Briggs,
Martin Friebe,
Sergey Zhuravlev,
.SH "COPYRIGHT, LICENSE AND WARRANTY"
.IX Header "COPYRIGHT, LICENSE AND WARRANTY"
This program is copyright (c) 2007 Baron Schwartz.
Feedback and improvements are welcome.
.PP
\&\s-1THIS\s0 \s-1PROGRAM\s0 \s-1IS\s0 \s-1PROVIDED\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1AND\s0 \s-1WITHOUT\s0 \s-1ANY\s0 \s-1EXPRESS\s0 \s-1OR\s0 \s-1IMPLIED\s0
\&\s-1WARRANTIES\s0, \s-1INCLUDING\s0, \s-1WITHOUT\s0 \s-1LIMITATION\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0
\&\s-1MERCHANTIBILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
.PP
This program is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 General Public License as published by the Free Software
Foundation, version 2; \s-1OR\s0 the Perl Artistic License.  On \s-1UNIX\s0 and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, \s-1MA\s0  02111\-1307  \s-1USA\s0.
.SH "VERSION"
.IX Header "VERSION"
This manual page documents Ver 1.1.28 Distrib 2152 \f(CW$Revision:\fR 2145 $.
